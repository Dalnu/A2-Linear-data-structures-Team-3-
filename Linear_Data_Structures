class Doctor:
    """Class represent a doctor"""
    def __init__(self, name, specialization):
        self.name = name  # Initialize the name attribute of the doctor
        self.specialization = specialization  # Initialize the specialization attribute of the doctor

# Define the PatientRec class to represent patient records
class PatientRec:
    """Class represent the patient records"""
    def __init__(self, name, dob, contactInfo, medicalHistory = None, currCondition = None, docAssigned = None, appointmentDetails = None, medications = None):
        # Initialize patient attributes
        self.name = name  # Patient's name
        self.dob = dob  # Patient's date of birth
        self.contactInfo = contactInfo  # Patient's contact information
        self.medicalHistory = medicalHistory if medicalHistory else []  # Patient's medical history
        self.currCondition = currCondition  # Patient's current medical condition
        self.docAssigned = docAssigned  # Doctor assigned to the patient
        self.appointmentDetails = appointmentDetails  # Details of the patient's appointment
        self.medications = medications if medications else []  # Medications prescribed to the patient

    # Method to update the patient's medical history
    def update_medical_history(self, new_entry):
        self.medicalHistory.append(new_entry)

    # Method to add a medication to the patient's prescription list
    def add_medication(self, medication):
        self.medications.append(medication)

# Define the Node class for the queue implementation
class Node:
    """Class represent the node"""
    def __init__(self, data):
        # Initialize the node with data and a reference to the next node
        self.data = data  # Data stored in the node
        self.next = None  # Reference to the next node

# Define the Queue class to implement a queue using linked list
class Queue:
    """Class represent a queue"""
    def __init__(self):
        # Initialize the queue with front and rear pointers
        self.front = None  # Pointer to the front of the queue
        self.rear = None  # Pointer to the rear of the queue

    # Method to enqueue (add) data to the queue
    def enqueue(self, data):
        new_node = Node(data)  # Create a new node with the given data
        if self.rear is None:
            # If the queue is empty, set both front and rear to the new node
            self.front = self.rear = new_node
            return
        # Otherwise, add the new node to the rear of the queue and update the rear pointer
        self.rear.next = new_node
        self.rear = new_node

    # Method to dequeue (remove) data from the queue
    def dequeue(self):
        if self.front is None:
            # If the queue is empty, return None
            return None
        temp = self.front  # Store the front node
        self.front = temp.next  # Move the front pointer to the next node
        if self.front is None:
            # If the queue becomes empty after dequeue, update the rear pointer to None
            self.rear = None
        return temp.data  # Return the data of the dequeued node

    # Method to peek at the front element of the queue
    def peek(self):
        return self.front.data if self.front else None  # Return the data of the front node if it exists

    # Method to check if the queue is empty
    def isEmpty(self):
        return self.front is None  # Return True if the front pointer is None, indicating an empty queue
    # Method to make the queue iterable
    def __iter__(self):
        current = self.front
        while current:
            yield current.data
            current = current.next

# Define the PrescriptionStack class to implement a stack for prescriptions
class PrescriptionStack:
    def __init__(self):
        # Initialize the stack with an empty list
        self.stack = []

    # Method to push a prescription onto the stack
    def push(self, prescription):
        self.stack.append(prescription)  # Append the prescription to the stack

    # Method to pop (remove and return) the top prescription from the stack
    def pop(self):
        if self.is_empty():
            # If the stack is empty, return None
            return None
        return self.stack.pop()  # Otherwise, pop and return the top prescription

    # Method to peek at the top prescription of the stack without removing it
    def peek(self):
        return self.stack[-1] if not self.is_empty() else None  # Return the top prescription if the stack is not empty

    # Method to check if the stack is empty
    def isEmpty(self):
        return len(self.stack) == 0  # Return True if the stack is empty, False otherwise


class ConsultationQueue:
    """Class represent the queue for managing patient consultations"""
    def __init__(self):
        self.front = None
        self.rear = None

    def enqueue(self, patient):
        new_node = Node(patient)
        if self.rear is None:
            self.front = self.rear = new_node
            return
        self.rear.next = new_node
        self.rear = new_node

    def dequeue(self):
        if self.front is None:
            return None
        temp = self.front
        self.front = temp.next
        if self.front is None:
            self.rear = None
        return temp.data

    def peek(self):
        return self.front.data if self.front else None

    def isEmpty(self):
        return self.front is None




# Add New Patient Record Function
def addPatientRec(patient, patientQueue):
    patientQueue.enqueue(patient)  # Enqueue the new patient into the patient queue
    print("Patient record added successfully.")  # Print a success message

# Update Patient Record Function
def updatePatient(patient, patientQueue):
    updatedPatient = None  # Initialize updatedPatient to None
    tempQueue = Queue()  # Initialize a temporary queue
    found_patient = False  # Flag to track if the patient was found
    while not patientQueue.is_empty():
        currPatient = patientQueue.dequeue()  # Dequeue the current patient
        if currPatient.name == patient.name:  # Check if the current patient matches the provided patient
            found_patient = True  # Set found_patient flag to True
            print("Patient found. Here is the information:")
            print("Name:", currPatient.name)
            print("Date of Birth:", currPatient.dob)
            print("Contact Info:", currPatient.contactInfo)
            print("Medical History:", currPatient.medicalHistory)
            print("Current Condition:", currPatient.currCondition)
            print("Doctor Assigned:", currPatient.docAssigned)
            print("Appointment Details:", currPatient.appointmentDetails)
            print("Medications:", currPatient.medications)

            # Prompt user to select the section to update
            print("\nWhich section would you like to update?")
            print("1. Medical History")
            print("2. Current Condition")
            print("3. Doctor Assigned")
            print("4. Appointment Details")
            print("5. Medications")
            section_choice = input("Enter your choice (1-5): ")

            # Update the selected section
            if section_choice == "1":
                medical_history = input("Enter patient's new medical history (if any): ")
                currPatient.update_medical_history(medical_history)
            elif section_choice == "2":
                curr_condition = input("Enter patient's new current condition (if any): ")
                currPatient.currCondition = curr_condition
            elif section_choice == "3":
                doc_assigned = input("Enter doctor's name: ")
                currPatient.docAssigned = doc_assigned
            elif section_choice == "4":
                appointment_details = input("Enter appointment details: ")
                currPatient.appointmentDetails = appointment_details
            elif section_choice == "5":
                medication = input("Enter new medication: ")
                currPatient.add_medication(medication)
            else:
                print("Invalid choice.")
            updatedPatient = currPatient  # Set updatedPatient to the updated patient
            # Ask the user if they want to update anything else
            choice = input("Do you want to update anything else? (yes/no): ").lower()
            if choice == "no":
                break
        tempQueue.enqueue(currPatient)  # Enqueue the current patient into the temporary queue
    while not tempQueue.is_empty():
        patientQueue.enqueue(tempQueue.dequeue())  # Re-enqueue patients from the temporary queue back into the patient queue
    if updatedPatient:
        print("Patient record updated successfully.")  # Print a success message if the patient was updated, otherwise print a failure message
    else:
        if not found_patient:
            print("Patient not found.")  # Print a failure message if the patient was not found.


# Schedule Appointment Function
def scheAppoint(patient, doctor, appointment_time):
    patient.appointmentDetails = (doctor.name, appointment_time)  # Set the patient's appointment details
    print("Appointment scheduled successfully.")  # Print a success message

# Issue Prescription Function
def issuPrescription(patient, prescStack, prescription):
    patient.medications.append(prescription)  # Add the prescription to the patient's medications
    prescStack.push(prescription)  # Push the prescription onto the prescription stack
    print("Prescription issued successfully.")  # Print a success message

# Search Patient Function
def searPatient(patientName, patientQueue):
    found = False  # Initialize a flag to track if the patient was found
    while not patientQueue.isEmpty():
        currPatient = patientQueue.dequeue()  # Dequeue the current patient
        if currPatient.name == patientName:  # Check if the current patient matches the provided patient name
            found = True  # Set found flag to True
            print("Patient Name:", currPatient.name)  # Print the patient's name
            print("Date of Birth:", currPatient.dob)  # Print the patient's date of birth
            print("Contact Info:", currPatient.contactInfo)  # Print the patient's contact info
            print("Medical History:", currPatient.medicalHistory)  # Print the patient's medical history
            print("Current Condition:", currPatient.currCondition)  # Print the patient's current condition
            print("Doctor Assigned:", currPatient.docAssigned)  # Print the doctor assigned to the patient
            print("Appointment Details:", currPatient.appointmentDetails)  # Print the patient's appointment details
            print("Medications:", currPatient.medications)  # Print the patient's medications
            break  # Break out of the loop
    if not found:
        print("Patient not found.")  # Print a failure message if the patient was not found.





# Define the function to remove a patient record
def removePatientRec(patientName, patientQueue):
    tempQueue = Queue()  # Initialize a temporary queue
    found = False  # Flag to track if the patient was found
    while not patientQueue.isEmpty():
        currPatient = patientQueue.dequeue()  # Dequeue the current patient
        if currPatient.name == patientName:  # Check if the current patient matches the provided patient name
            found = True  # Set found flag to True
            print("Patient record removed successfully.")
        else:
            tempQueue.enqueue(currPatient)  # Enqueue patients other than the one to be removed into the temporary queue
    if not found:
        print("Patient not found.")  # Print a failure message if the patient was not found.
    # Re-enqueue patients from the temporary queue back into the patient queue
    while not tempQueue.isEmpty():
        patientQueue.enqueue(tempQueue.dequeue())

