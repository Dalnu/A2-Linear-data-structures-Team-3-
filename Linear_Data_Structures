# Define the PatientRec class to represent patient records
class PatientRec:
    def __init__(self, name, dob, contactInfo, medicalHistory = None, currCondition = None, docAssigned = None, appointmentDetails = None, medications = None):
        # Initialize patient attributes
        self.name = name  # Patient's name
        self.dob = dob  # Patient's date of birth
        self.contactInfo = contactInfo  # Patient's contact information
        self.medicalHistory = medicalHistory if medicalHistory else []  # Patient's medical history
        self.currCondition = currCondition  # Patient's current medical condition
        self.docAssigned = docAssigned  # Doctor assigned to the patient
        self.appointmentDetails = appointmentDetails  # Details of the patient's appointment
        self.medications = medications if medications else []  # Medications prescribed to the patient

    # Method to update the patient's medical history
    def update_medical_history(self, new_entry):
        self.medicalHistory.append(new_entry)

    # Method to add a medication to the patient's prescription list
    def add_medication(self, medication):
        self.medications.append(medication)

# Define the Node class for the queue implementation
class Node:
    def __init__(self, data):
        # Initialize the node with data and a reference to the next node
        self.data = data  # Data stored in the node
        self.next = None  # Reference to the next node

# Define the Queue class to implement a queue using linked list
class Queue:
    def __init__(self):
        # Initialize the queue with front and rear pointers
        self.front = None  # Pointer to the front of the queue
        self.rear = None  # Pointer to the rear of the queue

    # Method to enqueue (add) data to the queue
    def enqueue(self, data):
        new_node = Node(data)  # Create a new node with the given data
        if self.rear is None:
            # If the queue is empty, set both front and rear to the new node
            self.front = self.rear = new_node
            return
        # Otherwise, add the new node to the rear of the queue and update the rear pointer
        self.rear.next = new_node
        self.rear = new_node

    # Method to dequeue (remove) data from the queue
    def dequeue(self):
        if self.front is None:
            # If the queue is empty, return None
            return None
        temp = self.front  # Store the front node
        self.front = temp.next  # Move the front pointer to the next node
        if self.front is None:
            # If the queue becomes empty after dequeue, update the rear pointer to None
            self.rear = None
        return temp.data  # Return the data of the dequeued node

    # Method to peek at the front element of the queue
    def peek(self):
        return self.front.data if self.front else None  # Return the data of the front node if it exists

    # Method to check if the queue is empty
    def isEmpty(self):
        return self.front is None  # Return True if the front pointer is None, indicating an empty queue

# Define the PrescriptionStack class to implement a stack for prescriptions
class PrescriptionStack:
    def __init__(self):
        # Initialize the stack with an empty list
        self.stack = []

    # Method to push a prescription onto the stack
    def push(self, prescription):
        self.stack.append(prescription)  # Append the prescription to the stack

    # Method to pop (remove and return) the top prescription from the stack
    def pop(self):
        if self.is_empty():
            # If the stack is empty, return None
            return None
        return self.stack.pop()  # Otherwise, pop and return the top prescription

    # Method to peek at the top prescription of the stack without removing it
    def peek(self):
        return self.stack[-1] if not self.is_empty() else None  # Return the top prescription if the stack is not empty

    # Method to check if the stack is empty
    def isEmpty(self):
        return len(self.stack) == 0  # Return True if the stack is empty, False otherwise

